{
  "name": "pusher",
  "description": "Node.js client to interact with the Pusher REST API",
  "version": "1.0.0",
  "author": {
    "name": "Pusher",
    "email": "support@pusher.com"
  },
  "contributors": [
    {
      "name": "fabrik42",
      "email": "fabrik42@gmail.com"
    },
    {
      "name": "Jaewoong Kim",
      "email": "jwoongkim@gmail.com"
    },
    {
      "name": "Phil Leggetter",
      "email": "phil@leggetter.co.uk"
    },
    {
      "name": "Paweł Ledwoń",
      "email": "me@ludvik.pl"
    }
  ],
  "dependencies": {
    "request": "=2.36.0"
  },
  "devDependencies": {
    "mocha": "=1.20.1",
    "expect.js": "=0.3.1",
    "sinon": "=1.10.2",
    "nock": "=0.28.0",
    "express": "=3.11.0"
  },
  "keywords": [
    "pusher",
    "websockets",
    "realtime"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/pusher/pusher-node-server"
  },
  "main": "lib/pusher",
  "engines": {
    "node": ">= 0.8.0"
  },
  "readme": "# Pusher Node.js REST library\n\nIn order to use this library, you need to have an account on <http://pusher.com>. After registering, you will need the application credentials for your app.\n\n## Installation\n\nYou need to be running Node.js 0.8+ to use this library.\n\n```\n$ npm install pusher\n```\n\n## Configuration\n\nThere are 3 ways to configure the client. First one is just using the Pusher constructor:\n\n```javascript\nvar Pusher = require('pusher');\n\nvar pusher = new Pusher({\n  appId: 'APP_ID',\n  key: 'APP_KEY',\n  secret: 'SECRET_KEY',\n  encrypted: ENCRYPTED, // optional, defaults to false\n  host: 'HOST', // optional, defaults to api.pusherapp.com\n  port: PORT, // optional, defaults to 80 for unencrypted and 443 for encrypted\n});\n```\n\nFor specific clusters, you can use the `forCluster` function:\n\n```javascript\nvar Pusher = require('pusher');\n\nvar pusher = Pusher.forCluster(\"CLUSTER\", {\n  appId: 'APP_ID',\n  key: 'APP_KEY',\n  secret: 'SECRET_KEY',\n  encrypted: ENCRYPTED, // optional, defaults to false\n  port: PORT, // optional, defaults to 80 for unencrypted and 443 for encrypted\n});\n```\n\nYou can also specify auth and endpoint options by passing an URL:\n\n```javascript\nvar Pusher = require('pusher');\n\nvar pusher = Pusher.forURL(\"SCHEME://APP_KEY:SECRET_KEY@HOST:PORT/apps/APP_ID\");\n```\n\nYou can pass the optional second argument with options, as in `forCluster` function.\n\nThis is useful for example on Heroku, which sets the PUSHER_URL environment\nvariable to such URL, if you have the Pusher addon installed.\n\n#### Additional options\n\nThere are a few additional options that can be used in all above methods:\n\n```javascript\nvar Pusher = require('pusher');\n\nvar pusher = new Pusher({\n  // you can set other options in any of the 3 ways described above\n  proxy: 'HTTP_PROXY_URL', // optional, URL to proxy the requests through\n  timeout: TIMEOUT, // optional, timeout for all requests in milliseconds\n  keepAlive: KEEP_ALIVE // optional, enables keep-alive, defaults to false\n});\n```\n\n## Usage\n\n### Callbacks and error handling\n\n#### API requests\n\nAsynchronous methods on the Pusher class (`trigger`, `get` and `post`) take an optional callback as the last argument. After performing the request, the callback is called with three arguments:\n\n- error - if the request can't be performed or returns an error code, error will contain details, otherwise it will be null\n- request - the request object\n- response - the response object - can be undefined if response was not received\n\nAll operational errors are wrapped into a Pusher.RequestError object.\n\n#### WebHooks\n\nIn case accessing data for invalid WebHooks, an Pusher.WebHookError exception will be thrown from the called method. It is recommended to validate the WebHook before interpreting it.\n\n### Publishing events\n\nTo send an event to one or more channels use the trigger function. Channel names can contain only characters which are alphanumeric, '_' or '-' and have to be at most 200 characters long. Event name can be at most 200 characters long too.\n\n#### Single channel\n\n```javascript\npusher.trigger('channel-1', 'test_event', { message: \"hello world\" });\n```\n\n#### Multiple channels\n\n```javascript\npusher.trigger([ 'channel-1', 'channel-2' ], 'test_event', { message: \"hello world\" });\n```\n\nYou can trigger an event to at most 10 channels at once. Passing more than 10 channels will cause an exception to be thrown.\n\n### Excluding event recipients\n\nIn order to avoid the client that triggered the event from also receiving it, the `trigger` function takes an optional `socketId` parameter. For more informaiton see: <http://pusher.com/docs/publisher_api_guide/publisher_excluding_recipients>.\n\n```javascript\nvar socketId = '1302.1081607';\npusher.trigger(channel, event, data, socketId);\n```\n\n### Authenticating private channels\n\nTo authorise your users to access private channels on Pusher, you can use the `auth` function:\n\n```javascript\nvar auth = pusher.auth(socketId, channel);\n```\n\nFor more information see: <http://pusher.com/docs/authenticating_users>\n\n### Authenticating presence channels\n\nUsing presence channels is similar to private channels, but you can specify extra data to identify that particular user:\n\n```javascript\nvar channelData = {\n\tuser_id: 'unique_user_id',\n\tuser_info: {\n\t  name: 'Phil Leggetter'\n\t  twitter_id: '@leggetter'\n\t}\n};\nvar auth = pusher.auth(socketId, channel, channelData);\n```\n\nThe `auth` is then returned to the caller as JSON.\n\nFor more information see: <http://pusher.com/docs/authenticating_users>\n\n### Application state\n\nIt's possible to query the state of the application using the `pusher.get` function.\n\n```javascript\npusher.get({ path: path, params: params }, callback);\n```\n\nThe `path` property identifies the resource that the request should be made to and the `params` property should be a map of additional query string key and value pairs.\n\nParams can't include following keys:\n- auth_key\n- auth_timestamp\n- auth_version\n- auth_signature\n- body_md5\n\nThe following example provides the signature of the callback and an example of parsing the result:\n```javascript\npusher.get({ path: '/channels', params: {} }, function(error, request, response) {\n\tif (response.statusCode === 200) {\n\t\tvar result = JSON.parse(response.body);\n\t\tvar channelsInfo = result.channels;\n\t}\n});\n```\n\n#### Get the list of channels in an application\n\n```javascript\npusher.get({ path: '/channels', params: params }, callback);\n```\n\nInformation on the optional `params` and the structure of the returned JSON is defined in the [REST API reference](http://pusher.com/docs/rest_api#method-get-channels).\n\n#### Get the state of a channel\n\n```javascript\npusher.get({ path: '/channels/[channel_name]', params: params }, callback);\n```\n\nInformation on the optional `params` option property and the structure of the returned JSON is defined in the [REST API reference](http://pusher.com/docs/rest_api#method-get-channel).\n\n#### Get the list of users in a presence channel\n\n```javascript\npusher.get({ path: '/channels/[channel_name]/users' }, callback);\n```\n\nThe `channel_name` in the path must be a [presence channel](http://pusher.com/docs/presence). The structure of the returned JSON is defined in the [REST API reference](http://pusher.com/docs/rest_api#method-get-users).\n\n### WebHooks\n\nThe library provides a simple helper for WebHooks, which can be accessed via Pusher instances:\n\n```javascript\nvar webhook = pusher.webhook(request);\n```\n\nRequests must expose following fields:\n- headers - object with request headers indexed by lowercase header names\n- rawBody - string with the WebHook request body\n\nSince neither Node.js nor express provide the body in the request, your application needs to read it and assign to the request object. See examples/webhook_endpoint.js for a simple webhook endpoint implementation using the express framework.\n\nHeaders object must contain following headers:\n- x-pusher-key - application key, sent by Pusher\n- x-pusher-signature - WebHook signature, generated by Pusher\n- content-type - must be set to application/json, what Pusher does\n\nAfter instantiating the WebHook object, you can use its following methods:\n\n#### isValid\n\nValidates the content type, body format and signature of the WebHook and returns a boolean. Your application should validate incoming webhooks, otherwise they could be faked.\n\nAccepts an optional parameter containing additional application tokens (useful e.g. during migrations):\n\n```javascript\nvar webhook = pusher.webhook(request);\n// will check only the key and secret assigned to the pusher object:\nwebhook.isValid();\n// will also check two additional tokens:\nwebhook.isValid([{ key: \"x1\", secret: \"y1\" }, { key: \"x2\", secret: \"y2\" }]);\n```\n\n#### getData\n\nReturns the parsed WebHook body. Throws a Pusher.WebHookError if the WebHook is invalid, so please check the `isValid` result before accessing the data.\n\n```javascript\n// will return an object with the WebHook data\nwebhook.getData();\n```\n\nPlease read [the WebHooks documentation](http://pusher.com/docs/webhooks) to find out what fields are included in the body.\n\n#### getEvents\n\nReturns events included in the WebHook as an array. Throws a Pusher.WebHookError if the WebHook is invalid, so please check the `isValid` result before accessing the events.\n\n```javascript\n// will return an array with the events\nwebhook.getEvents();\n```\n\n#### getTime\n\nReturns the Date object for the time when the WebHook was sent from Pusher. Throws a Pusher.WebHookError if the WebHook is invalid, so please check the `isValid` result before accessing the time.\n\n```javascript\n// will return a Date object\nwebhook.getTime();\n```\n\n### Generating REST API signatures\n\nIf you wanted to send the REST API requests manually (e.g. using a different HTTP client), you can use the `createSignedQueryString` method to generate the whole request query string that includes the auth keys and your parameters.\n\n```javascript\npusher.createSignedQueryString(options);\n```\n\nThe only argument needs must be an object with following keys:\n- method - the HTTP request method\n- body - optional, the HTTP request body\n- params - optional, the object representing the query params\n\nQuery parameters can't contain following keys, as they are used to sign the request:\n\n- auth_key\n- auth_timestamp\n- auth_version\n- auth_signature\n- body_md5\n\n## Testing\n\nThe tests run using [Mocha](http://visionmedia.github.io/mocha/). Make sure\nyou've got all required modules installed:\n\n    npm install\n\n### Running the local test suite\n\nYou can run local integration tests without setting up a Pusher app:\n\n    node_modules/.bin/mocha tests/integration/**/*.js\n\n### Running the complete test suite\n\nIn order to run the full test suite, first you need a Pusher app. When starting\nmocha, you need to set the PUSHER_URL environment variable to contain your\napp credentials, like following:\n\n    `PUSHER_URL='http://KEY:SECRET@api.pusherapp.com/' node_modules/.bin/mocha tests/**/*.js`\n\n## Credits\n\nThis library is based on the work of:\n* Christian Bäuerlein and his library pusher.\n* Jaewoong Kim and the node-pusher library.\n\n## License\n\nThis code is free to use under the terms of the MIT license.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/pusher/pusher-node-server/issues"
  },
  "homepage": "https://github.com/pusher/pusher-node-server",
  "_id": "pusher@1.0.0",
  "_from": "pusher@"
}
